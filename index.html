<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kalkulator by Kamil</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
    <style>
        #map { height: 350px; width: 100%; border-radius: 8px; z-index: 1; }
        .waypoint-card { transition: all 0.2s ease; cursor: grab; position: relative; z-index: 1; }
        .waypoint-card:focus-within { z-index: 100; }
        .waypoint-card:hover { transform: translateX(3px); background: #475569 !important; }
        .waypoint-card.disabled { opacity: 0.5; }
        .waypoint-card.disabled input { text-decoration: line-through; }
        .waypoint-card.dragging { opacity: 0.4; cursor: grabbing; transform: scale(0.98); }
        .waypoint-card.drag-over { border-color: #3b82f6 !important; border-style: dashed !important; background: #1e3a5f !important; }
        .drag-handle { cursor: grab; padding: 4px; border-radius: 4px; transition: all 0.15s ease; }
        .drag-handle:hover { background: #64748b; }
        .drag-handle:active { cursor: grabbing; }
        .segment-result { animation: fadeIn 0.3s ease; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .leaflet-routing-container { display: none; }
        .leaflet-routing-drag-helper { background: #f59e0b !important; border: 2px solid white !important; border-radius: 50% !important; }
        .leaflet-routing-drag-helper { background: #f59e0b !important; border: 2px solid white !important; border-radius: 50% !important; }
        .autocomplete-dropdown {
            position: absolute; background: #1e293b; border: 1px solid #475569;
            border-radius: 6px; max-height: 150px; overflow-y: auto; z-index: 9999 !important;
            width: calc(100% - 90px); margin-top: 2px; font-size: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
        }
        .autocomplete-dropdown.start-dropdown { width: calc(100% - 56px); }
        .autocomplete-item { padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #334155; color: #e2e8f0; }
        .autocomplete-item:hover { background: #334155; }
        .autocomplete-item:last-child { border-bottom: none; }
        .input-wrapper { position: relative; flex: 1; }
        .tab-btn { transition: all 0.2s ease; }
        .tab-btn.active { background: linear-gradient(to right, #3b82f6, #10b981); color: white; }
        .tab-btn:not(.active):hover { background: #475569; }
        .toggle-switch {
            position: relative; width: 32px; height: 18px; background: #475569;
            border-radius: 9px; cursor: pointer; transition: background 0.2s ease;
        }
        .toggle-switch.active { background: #22c55e; }
        .toggle-switch::after {
            content: ''; position: absolute; width: 14px; height: 14px;
            background: white; border-radius: 50%; top: 2px; left: 2px; transition: transform 0.2s ease;
        }
        .toggle-switch.active::after { transform: translateX(14px); }
        .leaflet-routing-drag-helper { background: #f59e0b !important; border: 2px solid white !important; border-radius: 50% !important; }
        .map-tab-btn { background: #334155; color: #94a3b8; }
        .map-tab-btn:hover { background: #475569; }
        .map-tab-btn.active { background: linear-gradient(to right, #3b82f6, #10b981); color: white; }
        #tmsTabBtn.active { background: linear-gradient(to right, #f59e0b, #ef4444); }
        #driversListBtn.active { box-shadow: 0 0 0 2px #818cf8; }
        #notesBtn.active { box-shadow: 0 0 0 2px #f59e0b; }
        #driversTable { table-layout: auto; width: 100%; }
        #driversTable input, #driversTable select {
            background: #334155; border: 1px solid #475569; border-radius: 4px;
            padding: 4px 6px; color: white; font-size: 11px; width: 100%;
        }
        #driversTable input:focus, #driversTable select:focus {
            outline: none; border-color: #6366f1;
        }
        #driversTable td { padding: 4px; border: 1px solid #475569; }
        #driversTable tr:hover td { background: #334155; }
        #driversTable tr:hover td { background: #334155; }

    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 min-h-screen text-white">
    <div class="container mx-auto px-3 py-4 max-w-7xl">
        <!-- Nag≈Ç√≥wek -->
        <div class="text-center mb-3">
            <h1 class="text-2xl font-bold bg-gradient-to-r from-blue-400 to-emerald-400 bg-clip-text text-transparent">
                üó∫Ô∏è Kalkulator by Kamil
            </h1>
            <p class="text-slate-400 text-xs">Obliczaj dystanse, czas podr√≥≈ºy i koszty ‚Ä¢ Powered by OpenStreetMap</p>
        </div>

        <!-- Zak≈Çadki -->
        <div class="bg-slate-800/50 rounded-lg p-2 border border-slate-700 mb-3">
            <div class="flex flex-col gap-2">
                <div class="flex items-center gap-2">
                    <button id="driversListBtn" onclick="toggleDriversList()" class="bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 px-3 py-1.5 rounded text-xs font-bold uppercase border border-indigo-500 transition flex items-center gap-1">
                        üöõ Lista Kierowc√≥w
                    </button>
                    <button id="notesBtn" onclick="toggleNotes()" class="bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-700 hover:to-orange-700 px-3 py-1.5 rounded text-xs font-bold uppercase border border-yellow-500 transition flex items-center gap-1">
                        üìù Notatki
                    </button>
                </div>
                <div class="flex items-center gap-1.5 flex-wrap">
                    <div id="tabsContainer" class="flex items-center gap-1.5 flex-wrap">
                        <button class="tab-btn active px-3 py-1.5 rounded text-xs font-bold uppercase border border-slate-600" data-tab="1" onclick="switchTab(1)" oncontextmenu="renameTab(event, 1)">üìã <span class="tab-name">Trasa 1</span></button>
                    </div>
                    <button onclick="addNewTab()" class="bg-slate-700 hover:bg-slate-600 px-2 py-1.5 rounded text-xs font-medium transition flex items-center gap-1 border border-slate-600">
                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                        Nowa
                    </button>
                </div>
            </div>
        </div>

        <div class="grid lg:grid-cols-2 gap-3">
            <!-- Lewy Panel -->
            <div class="space-y-3">
                <!-- Punkty trasy -->
                <div class="bg-slate-800/50 rounded-lg p-3 border border-slate-700">
                    <div class="flex items-center justify-between mb-2">
                        <h2 class="text-sm font-semibold flex items-center gap-1.5">üìç Punkty trasy</h2>
                        <button onclick="addWaypoint()" class="bg-emerald-600 hover:bg-emerald-700 px-2 py-1 rounded text-xs font-medium transition flex items-center gap-1">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                            Dodaj
                        </button>
                    </div>
                    
                    <div id="waypointsContainer" class="space-y-1.5">
                        <!-- Punkt startowy -->
                        <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="start" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                            <div class="flex items-center gap-2">
                                <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                                </div>
                                <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, 'start')"></div>
                                <span class="waypoint-label w-6 h-6 bg-green-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">S</span>
                                <div class="input-wrapper">
                                    <input type="text" id="waypoint-start" placeholder="Lokalizacja startowa" oninput="handleAutocomplete(this, 'start')" onfocus="handleAutocomplete(this, 'start')"
                                        class="w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-green-500">
                                    <div id="dropdown-start" class="autocomplete-dropdown start-dropdown hidden"></div>
                                </div>
                            </div>
                        </div>
                        <!-- Punkt A -->
                        <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="A" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                            <div class="flex items-center gap-2">
                                <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                                </div>
                                <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, 'A')"></div>
                                <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">A</span>
                                <div class="input-wrapper">
                                    <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt A" oninput="handleAutocomplete(this, 'A')" onfocus="handleAutocomplete(this, 'A')">
                                    <div id="dropdown-A" class="autocomplete-dropdown hidden"></div>
                                </div>
                                <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        </div>
                        <!-- Punkt B -->
                        <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="B" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                            <div class="flex items-center gap-2">
                                <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                                </div>
                                <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, 'B')"></div>
                                <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">B</span>
                                <div class="input-wrapper">
                                    <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt B" oninput="handleAutocomplete(this, 'B')" onfocus="handleAutocomplete(this, 'B')">
                                    <div id="dropdown-B" class="autocomplete-dropdown hidden"></div>
                                </div>
                                <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Lokalizacja ko≈Ñcowa -->
                    <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-red-600/50 mt-2" data-waypoint="end">
                        <div class="flex items-center gap-2">
                            <div class="shrink-0 text-slate-600 w-4 h-4"></div>
                            <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, 'end')"></div>
                            <span class="waypoint-label w-6 h-6 bg-red-600 rounded-full flex items-center justify-center text-xs shrink-0">üèÅ</span>
                            <div class="input-wrapper">
                                <input type="text" id="waypoint-end" placeholder="Lokalizacja ko≈Ñcowa" oninput="handleAutocomplete(this, 'end')" onfocus="handleAutocomplete(this, 'end')"
                                    class="w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-red-500">
                                <div id="dropdown-end" class="autocomplete-dropdown start-dropdown hidden"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Import z Google Maps -->
                    <div class="bg-gradient-to-r from-red-900/30 to-yellow-900/30 rounded p-2 border border-red-600/50 mt-2">
                        <div class="flex items-center gap-2">
                            <span class="text-xs font-medium whitespace-nowrap">üì• Import</span>
                            <input type="text" id="googleMapsImport" placeholder="Wklej URL z Google Maps (np. https://www.google.com/maps/dir/...)" 
                                class="flex-1 bg-slate-700 border border-slate-600 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-yellow-500">
                            <button onclick="importFromGoogleMaps()" class="bg-gradient-to-r from-red-500 to-yellow-500 hover:from-red-600 hover:to-yellow-600 px-3 py-1.5 rounded text-xs font-bold transition flex items-center gap-1">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                                Importuj
                            </button>
                        </div>
                        
                    </div>
                </div>

                <!-- Cena i Prƒôdko≈õƒá -->
                <div class="grid grid-cols-3 gap-2">
                    <!-- Cena -->
                    <div class="bg-slate-800/50 rounded-lg p-2.5 border border-slate-700">
                        <div class="flex items-center justify-between mb-1.5">
                            <span class="text-xs font-medium">üí∞ Cena</span>
                            <select id="currencySelector" onchange="updateCurrency()" class="bg-slate-700 border border-slate-600 rounded px-1.5 py-0.5 text-xs text-white focus:outline-none cursor-pointer">
                                <option value="PLN" selected>PLN</option>
                                <option value="EUR">EUR</option>
                                <option value="USD">USD</option>
                            </select>
                        </div>
                        <div class="relative">
                            <input type="number" id="totalPrice" placeholder="0.00" step="0.01" min="0" oninput="updatePricePerKmInput()"
                                class="w-full bg-slate-700 border border-slate-600 rounded px-2 py-1.5 pr-10 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-amber-500">
                            <span id="priceInputCurrency" class="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 text-xs">PLN</span>
                        </div>
                    </div>
                    
                    <!-- Oczekiwana stawka -->
                    <div class="bg-slate-800/50 rounded-lg p-2.5 border border-slate-700">
                        <div class="flex items-center justify-between mb-1.5">
                            <span class="text-xs font-medium">üéØ Oczekiwana</span>
                            <span id="expectedTotalDisplay" class="text-[10px] text-slate-400">= 0 <span id="expectedTotalCurrency">PLN</span></span>
                        </div>
                        <div class="relative">
                            <input type="number" id="expectedRate" placeholder="0.00" step="0.01" min="0" oninput="updateExpectedPrice()"
                                class="w-full bg-slate-700 border border-slate-600 rounded px-2 py-1.5 pr-16 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-cyan-500">
                            <span id="expectedRateCurrency" class="absolute right-2 top-1/2 -translate-y-1/2 text-slate-400 text-xs">PLN/km</span>
                        </div>
                    </div>
                    
                    <!-- Prƒôdko≈õƒá -->
                    <div class="bg-gradient-to-r from-orange-900/30 to-amber-900/30 rounded-lg p-2.5 border border-orange-700/50">
                        <div class="flex items-center justify-between mb-1.5">
                            <span class="text-xs font-medium">üöó Prƒôdko≈õƒá</span>
                            <span id="customTimeDisplay" class="text-sm font-bold text-orange-400">0h 0m</span>
                        </div>
                        <div class="flex items-center gap-1.5">
                            <input type="number" id="customSpeed" placeholder="80" step="1" min="1" max="300" value="80" oninput="updateCustomTime()"
                                class="w-full bg-slate-700 border border-slate-600 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-orange-500 text-center font-bold">
                            <span class="text-slate-400 text-xs shrink-0">km/h</span>
                        </div>
                    </div>
                </div>

                <!-- Podsumowanie -->
                <div class="bg-gradient-to-r from-purple-900/30 to-pink-900/30 rounded-lg p-2.5 border border-purple-700/50">
                    <div class="flex items-center gap-2 text-xs flex-wrap">
                        <div class="flex items-center gap-1.5 bg-slate-800/70 rounded px-2 py-1.5 border border-slate-600">
                            <span class="text-blue-400 font-bold" id="totalKmDisplay">0.00</span>
                            <span class="text-slate-400">km</span>
                        </div>
                        <span class="text-slate-500">√ó</span>
                        <div id="pricePerKmSummaryBox" class="flex items-center gap-1.5 bg-emerald-900/50 rounded px-2 py-1.5 border border-emerald-600/50 transition-all">
                            <span class="text-emerald-400 font-bold" id="pricePerKmDisplay">0.00</span>
                            <span id="pricePerKmUnit" class="text-slate-400">PLN/km</span>
                        </div>
                        <span class="text-slate-500">|</span>
                        <div class="flex items-center gap-1.5 bg-slate-700/70 rounded px-2 py-1 border border-slate-600">
                            <span class="text-cyan-400 font-bold" id="kmWithoutStartDisplay">0.00</span>
                            <span class="text-slate-400">km</span>
                        </div>
                        <span class="text-slate-500">‚Üí</span>
                        <div id="rateWithoutStartBox" class="flex items-center gap-1.5 bg-cyan-900/50 rounded px-2 py-1 border border-cyan-600/50 transition-all">
                            <span class="text-cyan-300 font-bold" id="rateWithoutStartDisplay">0.00</span>
                            <span id="rateWithoutStartUnit" class="text-slate-400">PLN/km</span>
                        </div>
                        <div class="hidden sm:flex items-center gap-1 ml-auto text-slate-500 font-mono" id="calcBreakdown">Oblicz trasƒô</div>
                    </div>
                    <!-- Hidden elements for compatibility -->
                    <span class="hidden" id="priceWithoutStartDisplay">0.00</span>
                    <span class="hidden" id="priceWithoutStartCurrency">PLN</span>
                </div>
                
                <!-- Przyciski akcji -->
                <div class="bg-slate-800/50 rounded-lg p-2.5 border border-slate-700">
                    <div class="flex gap-2">
                        <button onclick="calculateRoute()" id="calculateBtn" class="flex-1 bg-gradient-to-r from-blue-600 to-emerald-600 hover:from-blue-700 hover:to-emerald-700 py-2.5 rounded-lg font-bold text-sm transition transform hover:scale-[1.01] flex items-center justify-center gap-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"></path></svg>
                            <span id="calculateBtnText">Oblicz trasƒô</span>
                        </button>
                        <button onclick="exportToGoogleMaps()" id="exportBtn" class="bg-gradient-to-r from-red-500 to-yellow-500 hover:from-red-600 hover:to-yellow-600 py-2.5 px-4 rounded-lg font-bold text-sm transition transform hover:scale-[1.01] flex items-center justify-center gap-2" title="Otw√≥rz w Google Maps">
                            <svg class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>
                            <span class="hidden sm:inline">Google Maps</span>
                        </button>
                    </div>
                </div>

                <!-- Por√≥wnanie czasu -->
                <div id="timeComparison" class="hidden bg-slate-800/50 rounded-lg p-2 border border-slate-700">
                    <div class="flex items-center justify-center gap-3 text-xs">
                        <div class="text-center">
                            <p class="text-blue-300 text-[10px]">Szacowany OSRM</p>
                            <p id="osrmTimeCompare" class="font-bold text-blue-400">-</p>
                        </div>
                        <span class="text-slate-500">vs</span>
                        <div class="text-center">
                            <p class="text-orange-300 text-[10px]">Twoja prƒôdko≈õƒá</p>
                            <p id="customTimeCompare" class="font-bold text-orange-400">-</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Prawy Panel -->
            <div class="space-y-3">
                <!-- Mapa -->
                <div class="bg-slate-800/50 rounded-lg p-2 border border-slate-700">
                    <div class="flex items-center gap-1 mb-2">
                        <button id="osmTabBtn" onclick="switchMapMode('osm')" class="map-tab-btn active flex-1 py-1.5 px-3 rounded text-xs font-bold uppercase border border-slate-600 transition-all flex items-center justify-center gap-1">
                            üó∫Ô∏è OpenStreetMap
                        </button>
                        <button id="tmsTabBtn" onclick="switchMapMode('tms')" class="map-tab-btn flex-1 py-1.5 px-3 rounded text-xs font-bold uppercase border border-slate-600 transition-all flex items-center justify-center gap-1">
                            üöõ TMS (Ciƒô≈ºar√≥wki)
                        </button>
                    </div>
                    <div id="mapModeInfo" class="hidden bg-amber-900/30 border border-amber-600/50 rounded p-2 mb-2 text-xs text-amber-300">
                        <span class="font-bold">üöõ Tryb TMS:</span> Mapa PTV dla logistyki ciƒô≈ºarowej. Wy≈õwietla trasy transportowe i ograniczenia dla pojazd√≥w ciƒô≈ºarowych.
                    </div>
                    <div id="map"></div>
                </div>

                <!-- Wyniki -->
                <div id="resultsContainer" class="hidden bg-slate-800/50 rounded-lg p-3 border border-slate-700">
                    <h2 class="text-sm font-semibold flex items-center gap-1.5 mb-2">üìä Wyniki</h2>
                    
                    <div id="segmentResults" class="space-y-1.5 mb-3 max-h-40 overflow-y-auto"></div>
                    
                    <!-- Siatka podsumowania -->
                    <div class="grid grid-cols-5 gap-1.5 text-center">
                        <div class="bg-slate-700/50 rounded p-2">
                            <p class="text-slate-400 text-[10px]">Dystans</p>
                            <p id="totalDistance" class="text-sm font-bold text-white">0 km</p>
                        </div>
                        <div class="bg-slate-700/50 rounded p-2">
                            <p class="text-slate-400 text-[10px]">Czas</p>
                            <p id="totalTime" class="text-sm font-bold text-white">0 min</p>
                        </div>
                        <div class="bg-slate-700/50 rounded p-2">
                            <p class="text-slate-400 text-[10px]">Cena</p>
                            <p id="displayTotalPrice" class="text-sm font-bold text-emerald-400">0 PLN</p>
                        </div>
                        <div class="bg-slate-700/50 rounded p-2">
                            <p class="text-slate-400 text-[10px]">Za KM</p>
                            <p id="pricePerKm" class="text-sm font-bold text-amber-400">0 PLN</p>
                        </div>
                        <div class="bg-cyan-900/50 rounded p-2 border border-cyan-600/30">
                            <p class="text-cyan-400 text-[10px]">Bez podlotu</p>
                            <p id="rateWithoutStartResult" class="text-sm font-bold text-cyan-300">0 PLN/km</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Side-by-side container for Notes and Drivers List -->
        <div id="sideBySlideContainer" class="mt-3 grid lg:grid-cols-2 gap-3">
            <!-- Notes Panel -->
            <div id="notesPanel" class="hidden">
                <div class="bg-slate-800/50 rounded-lg p-3 border border-yellow-600/50 h-full">
                    <div class="flex items-center justify-between mb-2">
                        <h2 class="text-sm font-semibold flex items-center gap-2">
                            üìù Notatki
                        </h2>
                        <div class="flex items-center gap-2">
                            <button onclick="clearNotes()" class="bg-red-600/50 hover:bg-red-600 px-2 py-1 rounded text-xs font-medium transition flex items-center gap-1">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                Wyczy≈õƒá
                            </button>
                            <button onclick="toggleNotes()" class="bg-slate-600 hover:bg-slate-500 px-3 py-1 rounded text-xs font-medium transition">
                                Zamknij
                            </button>
                        </div>
                    </div>
                    <textarea id="notesTextarea" placeholder="Wpisz swoje notatki tutaj..." 
                        class="w-full h-40 bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-sm text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-yellow-500 resize-y"
                        oninput="saveNotes()"></textarea>
                    <div class="mt-2 text-xs text-slate-400">
                        <span id="notesCharCount">0</span> znak√≥w
                    </div>
                </div>
            </div>

            <!-- Lista Kierowc√≥w Panel -->
            <div id="driversListPanel" class="hidden">
            <div class="bg-slate-800/50 rounded-lg p-3 border border-slate-700">
                <div class="flex items-center justify-between mb-3">
                    <h2 class="text-sm font-semibold flex items-center gap-2">
                        üöõ Lista Kierowc√≥w
                    </h2>
                    <div class="flex items-center gap-2">
                        <button onclick="addDriverRow()" class="bg-emerald-600 hover:bg-emerald-700 px-3 py-1.5 rounded text-xs font-medium transition flex items-center gap-1">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg>
                            Dodaj wiersz
                        </button>
                        <button onclick="toggleDriversList()" class="bg-slate-600 hover:bg-slate-500 px-3 py-1.5 rounded text-xs font-medium transition">
                            Zamknij
                        </button>
                    </div>
                </div>
                
                <div class="overflow-x-auto">
                    <table class="w-full text-xs" id="driversTable">
                        <thead>
                            <tr class="bg-slate-700/50 text-slate-300 text-xs">
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">Kierowca</th>
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">CiƒÖgnik</th>
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">Naczepa</th>
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">Start</th>
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">Destynacja</th>
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">Nadwozie</th>
                                <th class="px-2 py-1.5 text-left font-semibold border border-slate-600">Status</th>
                                <th class="px-2 py-1.5 text-center font-semibold border border-slate-600">Akcje</th>
                            </tr>
                        </thead>
                        <tbody id="driversTableBody">
                            <!-- Rows will be added dynamically -->
                        </tbody>
                    </table>
                </div>
                
                <div class="mt-3 flex items-center justify-between text-xs text-slate-400">
                    <span id="driversCount">0 kierowc√≥w</span>
                    <div class="flex items-center gap-2">
                        <input type="file" id="csvFileInput" accept=".csv" onchange="importDriversFromCSV(event)" class="hidden">
                        <button onclick="document.getElementById('csvFileInput').click()" class="bg-emerald-700 hover:bg-emerald-600 px-2 py-1 rounded transition flex items-center gap-1">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                            Import CSV
                        </button>
                        <button onclick="exportDriversToCSV()" class="bg-slate-700 hover:bg-slate-600 px-2 py-1 rounded transition flex items-center gap-1">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                            Eksport CSV
                        </button>
                        <button onclick="clearAllDrivers()" class="bg-red-600/50 hover:bg-red-600 px-2 py-1 rounded transition flex items-center gap-1">
                            <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            Wyczy≈õƒá
                        </button>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    
    <script>
        let map, routingControl, markers = [], waypointCount = 2;
        const waypointLabels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let currentTotalKm = 0, currentKmWithoutStart = 0, currentCurrency = 'PLN', autocompleteTimeout;
        let geocodedLocations = {}, waypointEnabled = { start: true, A: true, B: true, end: true };
        let currentOsrmTime = 0;
        let tabs = { 1: { waypoints: {}, enabled: { start: true, A: true, B: true, end: true }, price: 0, currency: 'PLN', speed: 80, expectedRate: 0, name: 'Trasa 1' } };
        let currentTab = 1, tabCounter = 1;
        let draggedElement = null;
        let currentMapMode = 'osm';
        let osmLayer, ptvLayer;
        const searchCache = new Map();
        const PTV_API_KEY = 'RVVfOGQ5YzI3NDNjYzE5NDNhYThkNGFhZjllNGI1NWUyYmQ6YjEzMmJjMmItZjg1Yi00ZDgwLTg5MDUtYTdkOTAwNjRmMGNk';

        document.addEventListener('DOMContentLoaded', initMap);

        // Funkcje Drag and Drop
        function handleDragStart(e) {
            draggedElement = e.target.closest('.waypoint-card');
            draggedElement.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedElement.getAttribute('data-waypoint'));
        }

        function handleDragEnd(e) {
            const card = e.target.closest('.waypoint-card');
            if (card) card.classList.remove('dragging');
            document.querySelectorAll('.waypoint-card').forEach(c => c.classList.remove('drag-over'));
            draggedElement = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const card = e.target.closest('.waypoint-card');
            if (card && card !== draggedElement) {
                card.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            const card = e.target.closest('.waypoint-card');
            if (card) card.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetCard = e.target.closest('.waypoint-card');
            if (!targetCard || !draggedElement || targetCard === draggedElement) return;
            
            targetCard.classList.remove('drag-over');
            
            const container = document.getElementById('waypointsContainer');
            const cards = Array.from(container.querySelectorAll('.waypoint-card'));
            const draggedIndex = cards.indexOf(draggedElement);
            const targetIndex = cards.indexOf(targetCard);
            
            // Zapisz dane punkt√≥w przed zmianƒÖ kolejno≈õci
            const waypointData = [];
            cards.forEach(card => {
                const label = card.getAttribute('data-waypoint');
                const input = card.querySelector('input');
                waypointData.push({
                    value: input ? input.value : '',
                    geo: geocodedLocations[label],
                    enabled: waypointEnabled[label]
                });
            });
            
            // Zmie≈Ñ kolejno≈õƒá tablicy danych
            const [movedData] = waypointData.splice(draggedIndex, 1);
            waypointData.splice(targetIndex, 0, movedData);
            
            // Przenie≈õ element DOM
            if (draggedIndex < targetIndex) {
                targetCard.after(draggedElement);
            } else {
                targetCard.before(draggedElement);
            }
            
            // Przypisz nowe etykiety i dane
            reassignWaypointLabels(waypointData);
        }

        function reassignWaypointLabels(dataArray) {
            const container = document.getElementById('waypointsContainer');
            const cards = Array.from(container.querySelectorAll('.waypoint-card'));
            
            // Wyczy≈õƒá i odbuduj geocodedLocations i waypointEnabled
            const newGeo = {};
            const newEnabled = {};
            
            cards.forEach((card, index) => {
                const isFirst = index === 0;
                const label = isFirst ? 'start' : waypointLabels[index - 1];
                const data = dataArray[index];
                
                // Aktualizuj atrybut data-waypoint
                card.setAttribute('data-waypoint', label);
                
                // Aktualizuj znacznik etykiety
                const labelSpan = card.querySelector('.waypoint-label');
                if (labelSpan) {
                    labelSpan.textContent = isFirst ? 'S' : label;
                    labelSpan.className = `waypoint-label w-6 h-6 ${isFirst ? 'bg-green-600' : 'bg-blue-600'} rounded-full flex items-center justify-center text-xs font-bold shrink-0`;
                }
                
                // Aktualizuj input
                const input = card.querySelector('input');
                if (input) {
                    input.value = data.value || '';
                    input.placeholder = isFirst ? 'Lokalizacja startowa' : `Punkt ${label}`;
                    input.setAttribute('oninput', `handleAutocomplete(this, '${label}')`);
                    input.setAttribute('onfocus', `handleAutocomplete(this, '${label}')`);
                    if (isFirst) {
                        input.id = 'waypoint-start';
                        input.classList.remove('waypoint-input');
                        input.className = 'w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-green-500';
                    } else {
                        input.removeAttribute('id');
                        input.classList.add('waypoint-input');
                        input.className = 'waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500';
                    }
                }
                
                // Aktualizuj dropdown
                const dropdown = card.querySelector('.autocomplete-dropdown');
                if (dropdown) {
                    dropdown.id = `dropdown-${label}`;
                    dropdown.className = `autocomplete-dropdown ${isFirst ? 'start-dropdown' : ''} hidden`;
                }
                
                // Aktualizuj prze≈ÇƒÖcznik
                const toggle = card.querySelector('.toggle-switch');
                if (toggle) {
                    toggle.setAttribute('onclick', `toggleWaypoint(this, '${label}')`);
                    toggle.classList.toggle('active', data.enabled !== false);
                }
                
                // Aktualizuj stan wy≈ÇƒÖczenia karty
                card.classList.toggle('disabled', data.enabled === false);
                
                // Obs≈Çu≈º przycisk usuwania - pierwszy punkt nie powinien go mieƒá
                let deleteBtn = card.querySelector('button[onclick^="removeWaypoint"]');
                if (isFirst && deleteBtn) {
                    deleteBtn.remove();
                } else if (!isFirst && !deleteBtn) {
                    deleteBtn = document.createElement('button');
                    deleteBtn.setAttribute('onclick', 'removeWaypoint(this)');
                    deleteBtn.className = 'text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0';
                    deleteBtn.innerHTML = '<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>';
                    card.querySelector('.flex').appendChild(deleteBtn);
                }
                
                // Zapisz dane
                if (data.geo) newGeo[label] = data.geo;
                newEnabled[label] = data.enabled !== false;
            });
            
            geocodedLocations = newGeo;
            waypointEnabled = newEnabled;
            waypointCount = cards.length - 1;
        }

        function initMap() {
            map = L.map('map').setView([52.0693, 19.4803], 6);
            
            // OpenStreetMap layer
            osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors', 
                subdomains: 'abc', 
                maxZoom: 19
            });
            
            // PTV Developer Raster Map layer for trucks
            ptvLayer = L.tileLayer(`https://api.myptv.com/rastermaps/v1/image-tiles/{z}/{x}/{y}?apiKey=${PTV_API_KEY}&layers=transport,labels`, {
                attribution: '¬© <a href="https://www.myptv.com">PTV Group</a>, ¬© OpenStreetMap contributors',
                maxZoom: 19,
                tileSize: 256
            });
            
            // Add OSM layer by default
            osmLayer.addTo(map);
        }
        
        function switchMapMode(mode) {
            currentMapMode = mode;
            
            // Update tab buttons
            document.getElementById('osmTabBtn').classList.toggle('active', mode === 'osm');
            document.getElementById('tmsTabBtn').classList.toggle('active', mode === 'tms');
            
            // Update info panel
            document.getElementById('mapModeInfo').classList.toggle('hidden', mode === 'osm');
            
            // Switch map layers
            if (mode === 'tms') {
                // Remove OSM, add PTV
                if (map.hasLayer(osmLayer)) {
                    map.removeLayer(osmLayer);
                }
                if (!map.hasLayer(ptvLayer)) {
                    ptvLayer.addTo(map);
                }
            } else {
                // Remove PTV, add OSM
                if (map.hasLayer(ptvLayer)) {
                    map.removeLayer(ptvLayer);
                }
                if (!map.hasLayer(osmLayer)) {
                    osmLayer.addTo(map);
                }
            }
            
            // Recalculate route if waypoints exist
            if (currentTotalKm > 0) {
                calculateRoute();
            }
        }

        function toggleWaypoint(toggleEl, label) {
            const isActive = toggleEl.classList.contains('active');
            toggleEl.classList.toggle('active');
            waypointEnabled[label] = !isActive;
            const card = toggleEl.closest('.waypoint-card');
            if (card) card.classList.toggle('disabled', isActive);
            tabs[currentTab].enabled = { ...waypointEnabled };
        }

        function addNewTab() {
            // Find the next available tab number
            const existingNumbers = Object.keys(tabs).map(k => parseInt(k)).sort((a, b) => a - b);
            let newTabId = 1;
            for (let i = 1; i <= existingNumbers.length + 1; i++) {
                if (!existingNumbers.includes(i)) {
                    newTabId = i;
                    break;
                }
            }
            tabCounter = Math.max(tabCounter, newTabId);
            saveCurrentTabState();
            tabs[newTabId] = { waypoints: {}, enabled: { start: true, A: true, B: true, end: true }, price: 0, currency: 'PLN', speed: 80, expectedRate: 0, name: `Trasa ${newTabId}` };
            const tabsContainer = document.getElementById('tabsContainer');
            const tabBtn = document.createElement('button');
            tabBtn.className = 'tab-btn px-3 py-1.5 rounded text-xs font-bold uppercase border border-slate-600 flex items-center gap-1';
            tabBtn.setAttribute('data-tab', newTabId);
            tabBtn.innerHTML = `üìã <span class="tab-name">Trasa ${newTabId}</span> <span onclick="event.stopPropagation(); closeTab(${newTabId})" class="hover:bg-red-500/30 rounded p-0.5"><svg class="w-2.5 h-2.5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></span>`;
            tabBtn.onclick = () => switchTab(newTabId);
            tabBtn.oncontextmenu = (e) => renameTab(e, newTabId);
            tabsContainer.appendChild(tabBtn);
            switchTab(newTabId);
        }

        function renameTab(event, tabId) {
            event.preventDefault();
            event.stopPropagation();
            
            const tabBtn = document.querySelector(`[data-tab="${tabId}"]`);
            const tabNameSpan = tabBtn.querySelector('.tab-name');
            const currentName = tabs[tabId]?.name || tabNameSpan.textContent;
            
            const newName = prompt('Podaj nowƒÖ nazwƒô zak≈Çadki:', currentName);
            
            if (newName && newName.trim()) {
                const trimmedName = newName.trim();
                tabs[tabId].name = trimmedName;
                tabNameSpan.textContent = trimmedName;
            }
            
            return false;
        }

        function closeTab(tabId) {
            if (Object.keys(tabs).length <= 1) { alert('Nie mo≈ºna zamknƒÖƒá ostatniej zak≈Çadki'); return; }
            delete tabs[tabId];
            document.querySelector(`[data-tab="${tabId}"]`)?.remove();
            if (currentTab === tabId) switchTab(parseInt(Object.keys(tabs)[0]));
        }

        function switchTab(tabId) {
            saveCurrentTabState();
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.getAttribute('data-tab')) === tabId);
            });
            currentTab = tabId;
            loadTabState(tabId);
        }

        function saveCurrentTabState() {
            if (!tabs[currentTab]) return;
            const startInput = document.getElementById('waypoint-start');
            if (startInput) tabs[currentTab].waypoints['start'] = { value: startInput.value, geo: geocodedLocations['start'] };
            const endInput = document.getElementById('waypoint-end');
            if (endInput) tabs[currentTab].waypoints['end'] = { value: endInput.value, geo: geocodedLocations['end'] };
            document.querySelectorAll('.waypoint-card[data-waypoint]').forEach(card => {
                const label = card.getAttribute('data-waypoint');
                if (label === 'start' || label === 'end') return;
                const input = card.querySelector('.waypoint-input');
                if (input) tabs[currentTab].waypoints[label] = { value: input.value, geo: geocodedLocations[label] };
            });
            tabs[currentTab].enabled = { ...waypointEnabled };
            tabs[currentTab].price = parseFloat(document.getElementById('totalPrice').value) || 0;
            tabs[currentTab].currency = currentCurrency;
            tabs[currentTab].speed = parseFloat(document.getElementById('customSpeed').value) || 80;
            tabs[currentTab].expectedRate = parseFloat(document.getElementById('expectedRate').value) || 0;
        }

        function loadTabState(tabId) {
            const tabData = tabs[tabId];
            if (!tabData) return;
            
            // Restore tab name if exists
            const tabBtn = document.querySelector(`[data-tab="${tabId}"]`);
            if (tabBtn && tabData.name) {
                const tabNameSpan = tabBtn.querySelector('.tab-name');
                if (tabNameSpan) tabNameSpan.textContent = tabData.name;
            }
            const container = document.getElementById('waypointsContainer');
            
            // Start with base waypoints (start, A, B)
            container.innerHTML = `
                <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="start" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                    <div class="flex items-center gap-2">
                        <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                        </div>
                        <div class="toggle-switch ${tabData.enabled?.start !== false ? 'active' : ''} shrink-0" onclick="toggleWaypoint(this, 'start')"></div>
                        <span class="waypoint-label w-6 h-6 bg-green-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">S</span>
                        <div class="input-wrapper">
                            <input type="text" id="waypoint-start" placeholder="Lokalizacja startowa" oninput="handleAutocomplete(this, 'start')" onfocus="handleAutocomplete(this, 'start')" class="w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-green-500">
                            <div id="dropdown-start" class="autocomplete-dropdown start-dropdown hidden"></div>
                        </div>
                    </div>
                </div>
                <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="A" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                    <div class="flex items-center gap-2">
                        <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                        </div>
                        <div class="toggle-switch ${tabData.enabled?.A !== false ? 'active' : ''} shrink-0" onclick="toggleWaypoint(this, 'A')"></div>
                        <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">A</span>
                        <div class="input-wrapper">
                            <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt A" oninput="handleAutocomplete(this, 'A')" onfocus="handleAutocomplete(this, 'A')">
                            <div id="dropdown-A" class="autocomplete-dropdown hidden"></div>
                        </div>
                        <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                </div>
                <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="B" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                    <div class="flex items-center gap-2">
                        <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                        </div>
                        <div class="toggle-switch ${tabData.enabled?.B !== false ? 'active' : ''} shrink-0" onclick="toggleWaypoint(this, 'B')"></div>
                        <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">B</span>
                        <div class="input-wrapper">
                            <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt B" oninput="handleAutocomplete(this, 'B')" onfocus="handleAutocomplete(this, 'B')">
                            <div id="dropdown-B" class="autocomplete-dropdown hidden"></div>
                        </div>
                        <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                    </div>
                </div>`;
            
            // Add additional waypoints (C, D, E, etc.) if they exist in saved data
            if (tabData.waypoints) {
                const additionalLabels = Object.keys(tabData.waypoints).filter(label => 
                    label !== 'start' && label !== 'end' && label !== 'A' && label !== 'B'
                ).sort();
                
                additionalLabels.forEach(label => {
                    const isEnabled = tabData.enabled?.[label] !== false;
                    const div = document.createElement('div');
                    div.className = 'waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600';
                    div.setAttribute('data-waypoint', label);
                    div.setAttribute('draggable', 'true');
                    div.ondragstart = handleDragStart;
                    div.ondragend = handleDragEnd;
                    div.ondragover = handleDragOver;
                    div.ondragleave = handleDragLeave;
                    div.ondrop = handleDrop;
                    div.innerHTML = `
                        <div class="flex items-center gap-2">
                            <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                            </div>
                            <div class="toggle-switch ${isEnabled ? 'active' : ''} shrink-0" onclick="toggleWaypoint(this, '${label}')"></div>
                            <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">${label}</span>
                            <div class="input-wrapper">
                                <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt ${label}" oninput="handleAutocomplete(this, '${label}')" onfocus="handleAutocomplete(this, '${label}')">
                                <div id="dropdown-${label}" class="autocomplete-dropdown hidden"></div>
                            </div>
                            <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                        </div>`;
                    if (!isEnabled) div.classList.add('disabled');
                    container.appendChild(div);
                });
            }
            
            // Update end waypoint
            const endCard = document.querySelector('.waypoint-card[data-waypoint="end"]');
            if (endCard) {
                const endToggle = endCard.querySelector('.toggle-switch');
                if (endToggle) endToggle.classList.toggle('active', tabData.enabled?.end !== false);
                endCard.classList.toggle('disabled', tabData.enabled?.end === false);
            }
            
            geocodedLocations = {};
            waypointEnabled = { start: true, A: true, B: true, end: true };
            
            // Count all waypoints and restore their data
            let maxWaypointIndex = 1; // Start with B (index 1)
            if (tabData.waypoints) {
                Object.entries(tabData.waypoints).forEach(([label, data]) => {
                    if (label === 'start') {
                        const input = document.getElementById('waypoint-start');
                        if (input && data.value) { input.value = data.value; if (data.geo) geocodedLocations['start'] = data.geo; }
                    } else if (label === 'end') {
                        const input = document.getElementById('waypoint-end');
                        if (input && data.value) { input.value = data.value; if (data.geo) geocodedLocations['end'] = data.geo; }
                    } else {
                        // Find the index of this label in waypointLabels
                        const labelIndex = waypointLabels.indexOf(label);
                        if (labelIndex > maxWaypointIndex) maxWaypointIndex = labelIndex;
                        
                        const card = document.querySelector(`[data-waypoint="${label}"]`);
                        if (card) {
                            const input = card.querySelector('.waypoint-input');
                            if (input && data.value) { input.value = data.value; if (data.geo) geocodedLocations[label] = data.geo; }
                        }
                    }
                });
            }
            
            waypointCount = maxWaypointIndex + 1;
            
            if (tabData.enabled) {
                waypointEnabled = { ...tabData.enabled };
                Object.entries(tabData.enabled).forEach(([label, enabled]) => {
                    const card = document.querySelector(`[data-waypoint="${label}"]`);
                    if (card) {
                        card.querySelector('.toggle-switch')?.classList.toggle('active', enabled);
                        card.classList.toggle('disabled', !enabled);
                    }
                });
            }
            document.getElementById('totalPrice').value = tabData.price || '';
            document.getElementById('currencySelector').value = tabData.currency || 'PLN';
            currentCurrency = tabData.currency || 'PLN';
            document.getElementById('priceInputCurrency').textContent = currentCurrency;
            document.getElementById('pricePerKmUnit').textContent = `${currentCurrency}/km`;
            document.getElementById('expectedRateCurrency').textContent = `${currentCurrency}/km`;
            document.getElementById('customSpeed').value = tabData.speed || 80;
            document.getElementById('expectedRate').value = tabData.expectedRate || '';
            document.getElementById('expectedTotalDisplay').innerHTML = `= 0 <span id="expectedTotalCurrency">${currentCurrency}</span>`;
            // Reset end waypoint
            const endInput = document.getElementById('waypoint-end');
            if (endInput) endInput.value = tabData.waypoints?.end?.value || '';
            document.getElementById('resultsContainer').classList.add('hidden');
            currentTotalKm = 0; currentOsrmTime = 0; currentKmWithoutStart = 0;
            updatePricePerKmInput();
            document.getElementById('customTimeDisplay').textContent = '0h 0m';
            document.getElementById('timeComparison').classList.add('hidden');
            if (routingControl) { map.removeControl(routingControl); routingControl = null; }
            markers.forEach(m => map.removeLayer(m)); markers = [];
        }

        async function geocodeAddress(address) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`, { headers: { 'Accept-Language': 'pl' } });
                const data = await response.json();
                if (data?.length > 0) return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), display_name: data[0].display_name };
                return null;
            } catch (e) { console.error('B≈ÇƒÖd geokodowania:', e); return null; }
        }

        async function handleAutocomplete(input, id) {
            const query = input.value.trim();
            const dropdown = document.getElementById(`dropdown-${id}`);
            if (query.length < 2) { dropdown.classList.add('hidden'); return; }
            clearTimeout(autocompleteTimeout);
            
            // Check cache IMMEDIATELY before any delay
            const cacheKey = query.toLowerCase().trim();
            if (searchCache.has(cacheKey)) {
                displayResults(searchCache.get(cacheKey), dropdown, input, id);
                return;
            }
            
            // Show loading indicator immediately
            dropdown.innerHTML = '<div class="autocomplete-item text-slate-400"><span class="animate-pulse">üîç Szukam...</span></div>';
            dropdown.classList.remove('hidden');
            
            autocompleteTimeout = setTimeout(async () => {
                try {
                    // Check if input is coordinates
                    const coordPattern = /^(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)$/;
                    const coordMatch = query.match(coordPattern);
                    if (coordMatch) {
                        const lat = parseFloat(coordMatch[1]);
                        const lng = parseFloat(coordMatch[2]);
                        const isInEurope = lat >= 35 && lat <= 72 && lng >= -25 && lng <= 45;
                        
                        if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180 && isInEurope) {
                            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1`, { headers: { 'Accept-Language': 'pl' } });
                            const data = await response.json();
                            dropdown.innerHTML = '';
                            
                            if (data && !data.error) {
                                const addr = data.address || {};
                                const postcode = addr.postcode || '';
                                const city = addr.city || addr.town || addr.village || addr.municipality || '';
                                const state = addr.state || addr.region || '';
                                const country = addr.country || '';
                                let mainName = city || data.name || '';
                                let secondaryInfo = [state, country].filter(Boolean).join(', ');
                                
                                const item = document.createElement('div');
                                item.className = 'autocomplete-item';
                                item.innerHTML = `<div class="flex items-center gap-2"><span class="text-amber-400 text-lg">üìç</span><div><div class="text-amber-300 font-mono text-[11px]">${lat.toFixed(5)}, ${lng.toFixed(5)}</div>${postcode && mainName ? `<span class="text-emerald-400 font-mono font-bold">${postcode}</span> <span class="text-white font-semibold">${mainName}</span>` : `<span class="text-white">${data.display_name.split(',').slice(0,2).join(',')}</span>`}${secondaryInfo ? `<span class="text-slate-400 text-[10px]"> (${secondaryInfo})</span>` : ''}</div></div>`;
                                item.onclick = (e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    input.value = postcode && mainName ? `${postcode} ${mainName}` : data.display_name.split(',')[0];
                                    geocodedLocations[id] = { lat, lng, display_name: data.display_name, postcode, city: mainName };
                                    dropdown.classList.add('hidden');
                                    dropdown.innerHTML = '';
                                    input.blur();
                                    clearTimeout(autocompleteTimeout);
                                };
                                dropdown.appendChild(item);
                                
                                const rawItem = document.createElement('div');
                                rawItem.className = 'autocomplete-item';
                                rawItem.innerHTML = `<div class="flex items-center gap-2"><span class="text-blue-400 text-lg">üéØ</span><div><span class="text-blue-300 font-mono font-bold">${lat.toFixed(5)}, ${lng.toFixed(5)}</span><span class="text-slate-400 text-[10px]"> (u≈ºyj wsp√≥≈Çrzƒôdnych)</span></div></div>`;
                                rawItem.onclick = (e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    input.value = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
                                    geocodedLocations[id] = { lat, lng, display_name: `${lat.toFixed(5)}, ${lng.toFixed(5)}`, postcode: '', city: '' };
                                    dropdown.classList.add('hidden');
                                    dropdown.innerHTML = '';
                                    input.blur();
                                    clearTimeout(autocompleteTimeout);
                                };
                                dropdown.appendChild(rawItem);
                                dropdown.classList.remove('hidden');
                            } else {
                                dropdown.innerHTML = '<div class="autocomplete-item text-red-400">‚ùå Nie znaleziono lokalizacji</div>';
                            }
                            return;
                        } else if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                            dropdown.innerHTML = '<div class="autocomplete-item text-amber-400">‚ö†Ô∏è Wsp√≥≈Çrzƒôdne poza EuropƒÖ</div>';
                            return;
                        }
                    }
                    
                    // Single optimized search - Poland first with fallback
                    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=6&addressdetails=1&countrycodes=pl,de,cz,sk,ua,lt,by,ru`, { headers: { 'Accept-Language': 'pl' } });
                    let data = await response.json();
                    
                    // If not enough results, search broader Europe
                    if (data.length < 3) {
                        const euroResponse = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1&viewbox=-25,72,45,35&bounded=1`, { headers: { 'Accept-Language': 'pl' } });
                        const euroData = await euroResponse.json();
                        const existingIds = new Set(data.map(p => p.place_id));
                        data = [...data, ...euroData.filter(p => !existingIds.has(p.place_id))].slice(0, 6);
                    }
                    
                    // Cache results
                    if (searchCache.size > 50) searchCache.clear();
                    searchCache.set(cacheKey, data);
                    
                    displayResults(data, dropdown, input, id);
                } catch (e) { dropdown.classList.add('hidden'); }
            }, 80);
            
            function displayResults(data, dropdown, input, id) {
                if (data?.length > 0) {
                    dropdown.innerHTML = '';
                    data.forEach(place => {
                        const addr = place.address || {};
                        const postcode = addr.postcode || '';
                        const city = addr.city || addr.town || addr.village || addr.municipality || '';
                        const state = addr.state || addr.region || '';
                        const country = addr.country || '';
                        let mainName = city || place.name || '';
                        let secondaryInfo = [state, country].filter(Boolean).join(', ');
                        
                        const item = document.createElement('div');
                        item.className = 'autocomplete-item';
                        item.innerHTML = postcode && mainName 
                            ? `<span class="text-emerald-400 font-mono font-bold">${postcode}</span> <span class="text-white font-semibold">${mainName}</span>${secondaryInfo ? ` <span class="text-slate-400 text-[10px]">(${secondaryInfo})</span>` : ''}`
                            : postcode 
                                ? `<span class="text-emerald-400 font-mono font-bold">${postcode}</span> <span class="text-slate-300">${place.display_name}</span>`
                                : `<span class="text-slate-300">${place.display_name}</span>`;
                        
                        item.onclick = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            input.value = postcode && mainName ? `${postcode} ${mainName}` : postcode ? `${postcode} ${place.display_name.split(',')[0]}` : place.display_name;
                            geocodedLocations[id] = { lat: parseFloat(place.lat), lng: parseFloat(place.lon), display_name: place.display_name, postcode, city: mainName };
                            dropdown.classList.add('hidden');
                            dropdown.innerHTML = '';
                            input.blur();
                            clearTimeout(autocompleteTimeout);
                        };
                        dropdown.appendChild(item);
                    });
                    dropdown.classList.remove('hidden');
                } else dropdown.classList.add('hidden');
            }
        }

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.input-wrapper')) document.querySelectorAll('.autocomplete-dropdown').forEach(d => d.classList.add('hidden'));
        });

        // Close dropdowns when clicking on any input
        document.addEventListener('focusin', (e) => {
            if (e.target.tagName === 'INPUT') {
                const parentWrapper = e.target.closest('.input-wrapper');
                document.querySelectorAll('.autocomplete-dropdown').forEach(d => {
                    if (!parentWrapper || !parentWrapper.contains(d)) {
                        d.classList.add('hidden');
                    }
                });
            }
        });

        function addWaypoint() {
            const container = document.getElementById('waypointsContainer');
            const label = waypointLabels[waypointCount] || (waypointCount + 1);
            waypointCount++;
            waypointEnabled[label] = true;
            const div = document.createElement('div');
            div.className = 'waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600';
            div.setAttribute('data-waypoint', label);
            div.setAttribute('draggable', 'true');
            div.ondragstart = handleDragStart;
            div.ondragend = handleDragEnd;
            div.ondragover = handleDragOver;
            div.ondragleave = handleDragLeave;
            div.ondrop = handleDrop;
            div.innerHTML = `
                <div class="flex items-center gap-2">
                    <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                    </div>
                    <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, '${label}')"></div>
                    <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">${label}</span>
                    <div class="input-wrapper">
                        <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt ${label}" oninput="handleAutocomplete(this, '${label}')" onfocus="handleAutocomplete(this, '${label}')">
                        <div id="dropdown-${label}" class="autocomplete-dropdown hidden"></div>
                    </div>
                    <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                </div>`;
            container.appendChild(div);
        }

        function removeWaypoint(button) {
            const card = button.closest('.waypoint-card');
            if (card) {
                const label = card.getAttribute('data-waypoint');
                delete geocodedLocations[label];
                delete waypointEnabled[label];
                card.remove();
                updateWaypointLabels();
            }
        }

        function updateWaypointLabels() {
            const cards = document.querySelectorAll('.waypoint-card[data-waypoint]:not([data-waypoint="start"]):not([data-waypoint="end"])');
            const newEnabled = { start: waypointEnabled.start };
            cards.forEach((card, index) => {
                const label = waypointLabels[index] || (index + 1);
                const oldLabel = card.getAttribute('data-waypoint');
                newEnabled[label] = waypointEnabled[oldLabel] !== undefined ? waypointEnabled[oldLabel] : true;
                if (geocodedLocations[oldLabel]) { geocodedLocations[label] = geocodedLocations[oldLabel]; if (oldLabel !== label) delete geocodedLocations[oldLabel]; }
                card.setAttribute('data-waypoint', label);
                const labelSpan = card.querySelector('span:not(.toggle-switch)');
                if (labelSpan) labelSpan.textContent = label;
                const input = card.querySelector('input');
                if (input) { input.placeholder = `Punkt ${label}`; input.setAttribute('oninput', `handleAutocomplete(this, '${label}')`); input.setAttribute('onfocus', `handleAutocomplete(this, '${label}')`); }
                const dropdown = card.querySelector('.autocomplete-dropdown');
                if (dropdown) dropdown.id = `dropdown-${label}`;
                const toggle = card.querySelector('.toggle-switch');
                if (toggle) toggle.setAttribute('onclick', `toggleWaypoint(this, '${label}')`);
            });
            waypointEnabled = newEnabled;
            waypointCount = cards.length;
        }

        async function calculateRoute() {
            const btn = document.getElementById('calculateBtn');
            const btnText = document.getElementById('calculateBtnText');
            btn.disabled = true; btnText.textContent = 'Obliczanie...';
            try {
                const allPoints = [], pointNames = [];
                
                // Check start point (optional)
                const startInput = document.getElementById('waypoint-start').value.trim();
                if (startInput && waypointEnabled['start']) {
                    if (!geocodedLocations['start']) {
                        const startGeo = await geocodeAddress(startInput);
                        if (!startGeo) { alert('Nie mo≈ºna znale≈∫ƒá lokalizacji startowej.'); return; }
                        geocodedLocations['start'] = startGeo;
                    }
                    allPoints.push(geocodedLocations['start']);
                    pointNames.push('S');
                }
                
                const waypointCards = document.querySelectorAll('.waypoint-card[data-waypoint]:not([data-waypoint="start"]):not([data-waypoint="end"])');
                for (const card of waypointCards) {
                    const label = card.getAttribute('data-waypoint');
                    const input = card.querySelector('.waypoint-input');
                    const value = input.value.trim();
                    if (value) {
                        if (!geocodedLocations[label]) {
                            const geo = await geocodeAddress(value);
                            if (!geo) { alert(`Nie mo≈ºna znale≈∫ƒá punktu ${label}.`); return; }
                            geocodedLocations[label] = geo;
                        }
                        if (waypointEnabled[label]) { allPoints.push(geocodedLocations[label]); pointNames.push(label); }
                    }
                }
                
                // Check end point (optional)
                const endInput = document.getElementById('waypoint-end').value.trim();
                if (endInput && waypointEnabled['end']) {
                    if (!geocodedLocations['end']) {
                        const endGeo = await geocodeAddress(endInput);
                        if (!endGeo) { alert('Nie mo≈ºna znale≈∫ƒá lokalizacji ko≈Ñcowej.'); return; }
                        geocodedLocations['end'] = endGeo;
                    }
                    allPoints.push(geocodedLocations['end']);
                    pointNames.push('üèÅ');
                }
                if (allPoints.length < 2) { alert('W≈ÇƒÖcz co najmniej dwa punkty trasy'); return; }
                if (routingControl) map.removeControl(routingControl);
                markers.forEach(m => map.removeLayer(m)); markers = [];
                const routeWaypoints = allPoints.map(p => L.latLng(p.lat, p.lng));
                
                // Choose router based on map mode
                // Both use OSRM but TMS mode can use truck profile if available
                const router = L.Routing.osrmv1({
                    serviceUrl: 'https://router.project-osrm.org/route/v1',
                    profile: 'driving',
                    useHints: false,
                    routingOptions: {
                        alternatives: false,
                        steps: true,
                        annotations: true,
                        overview: 'full'
                    }
                });
                
                routingControl = L.Routing.control({
                    waypoints: routeWaypoints, 
                    routeWhileDragging: true, 
                    addWaypoints: true,
                    draggableWaypoints: true, 
                    fitSelectedRoutes: true, 
                    showAlternatives: false,
                    router: router,
                    lineOptions: { styles: [{ color: '#3b82f6', weight: 5, opacity: 0.8 }] },
                    createMarker: (i, wp, nWps) => {
                        const isStart = i === 0 && pointNames[i] === 'S';
                        const isEnd = i === nWps - 1 || pointNames[i] === 'üèÅ';
                        const label = pointNames[i] || (i + 1);
                        const markerColor = isStart ? '#22c55e' : (isEnd ? '#ef4444' : '#3b82f6');
                        const icon = L.divIcon({
                            className: 'custom-marker',
                            html: `<div style="background:${markerColor};color:white;width:28px;height:28px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:12px;border:3px solid white;box-shadow:0 2px 8px rgba(0,0,0,0.4);cursor:grab;">${label}</div>`,
                            iconSize: [28, 28], iconAnchor: [14, 14]
                        });
                        const marker = L.marker(wp.latLng, { icon, draggable: true });
                        marker.bindPopup(`<b>${label}</b><br><small>PrzeciƒÖgnij aby zmieniƒá</small>`);
                        
                        // Update input field when marker is dragged
                        marker.on('dragend', async function(e) {
                            const newLatLng = e.target.getLatLng();
                            try {
                                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${newLatLng.lat}&lon=${newLatLng.lng}&addressdetails=1`, { headers: { 'Accept-Language': 'pl' } });
                                const data = await response.json();
                                if (data) {
                                    const addr = data.address || {};
                                    const postcode = addr.postcode || '';
                                    const city = addr.city || addr.town || addr.village || addr.municipality || '';
                                    const newName = postcode && city ? `${postcode} ${city}` : data.display_name.split(',')[0];
                                    
                                    // Update the corresponding input field
                                    const waypointLabel = pointNames[i];
                                    if (waypointLabel === 'S') {
                                        document.getElementById('waypoint-start').value = newName;
                                        geocodedLocations['start'] = { lat: newLatLng.lat, lng: newLatLng.lng, display_name: data.display_name, postcode, city };
                                    } else if (waypointLabel === 'üèÅ') {
                                        document.getElementById('waypoint-end').value = newName;
                                        geocodedLocations['end'] = { lat: newLatLng.lat, lng: newLatLng.lng, display_name: data.display_name, postcode, city };
                                    } else {
                                        const card = document.querySelector(`[data-waypoint="${waypointLabel}"]`);
                                        if (card) {
                                            const input = card.querySelector('input');
                                            if (input) input.value = newName;
                                        }
                                        geocodedLocations[waypointLabel] = { lat: newLatLng.lat, lng: newLatLng.lng, display_name: data.display_name, postcode, city };
                                    }
                                }
                            } catch (e) { console.error('Reverse geocoding error:', e); }
                        });
                        
                        return marker;
                    }
                }).addTo(map);
                
                routingControl.on('routesfound', (e) => displayResults(e.routes[0], pointNames, allPoints));
                routingControl.on('routingerror', () => alert('Nie mo≈ºna obliczyƒá trasy.'));
            } catch (e) { console.error(e); alert('B≈ÇƒÖd podczas obliczania trasy.'); }
            finally { btn.disabled = false; btnText.textContent = 'Oblicz trasƒô'; }
        }

        function displayResults(route, pointNames, allPoints) {
            const instructions = route.instructions;
            const segments = [];
            const waypointIndices = route.waypointIndices || [];
            if (waypointIndices.length > 0) {
                for (let i = 0; i < waypointIndices.length - 1; i++) {
                    const startIdx = waypointIndices[i], endIdx = waypointIndices[i + 1];
                    let segmentDistance = 0, segmentTime = 0;
                    for (const inst of instructions) { if (inst.index >= startIdx && inst.index < endIdx) { segmentDistance += inst.distance || 0; segmentTime += inst.time || 0; } }
                    segments.push({ distance: segmentDistance / 1000, time: segmentTime });
                }
            } else {
                const totalSegments = pointNames.length - 1;
                const distPerSeg = route.summary.totalDistance / 1000 / totalSegments;
                const timePerSeg = route.summary.totalTime / totalSegments;
                for (let i = 0; i < totalSegments; i++) segments.push({ distance: distPerSeg, time: timePerSeg });
            }
            const totalDistance = route.summary.totalDistance / 1000;
            const totalDuration = route.summary.totalTime;
            currentOsrmTime = totalDuration;
            
            // Calculate distance without start (exclude first segment if start is "S")
            let kmWithoutStart = totalDistance;
            if (pointNames.length > 0 && pointNames[0] === 'S' && segments.length > 0) {
                kmWithoutStart = totalDistance - segments[0].distance;
            }
            currentKmWithoutStart = kmWithoutStart;
            
            const segmentResults = document.getElementById('segmentResults');
            segmentResults.innerHTML = '';
            segments.forEach((seg, i) => {
                const from = pointNames[i], to = pointNames[i + 1] || 'üèÅ';
                const div = document.createElement('div');
                div.className = 'segment-result bg-slate-700/50 rounded p-2 border border-slate-600 flex items-center justify-between text-xs';
                div.innerHTML = `<div class="flex items-center gap-1.5"><span class="w-5 h-5 bg-green-600 rounded-full flex items-center justify-center text-[10px] font-bold">${from}</span><span class="text-slate-500">‚Üí</span><span class="w-5 h-5 bg-red-600 rounded-full flex items-center justify-center text-[10px] font-bold">${to}</span></div><div class="text-right"><span class="font-bold text-blue-400">${seg.distance.toFixed(1)} km</span><span class="text-slate-500 ml-2">${formatDuration(seg.time)}</span></div>`;
                segmentResults.appendChild(div);
            });
            document.getElementById('totalDistance').textContent = totalDistance.toFixed(1) + ' km';
            document.getElementById('totalTime').textContent = formatDuration(totalDuration);
            currentTotalKm = totalDistance;
            document.getElementById('totalKmDisplay').textContent = totalDistance.toFixed(2);
            const totalPrice = parseFloat(document.getElementById('totalPrice').value) || 0;
            const pricePerKm = totalDistance > 0 ? (totalPrice / totalDistance) : 0;
            document.getElementById('displayTotalPrice').textContent = totalPrice.toFixed(0) + ' ' + currentCurrency;
            document.getElementById('pricePerKm').textContent = pricePerKm.toFixed(2) + ' ' + currentCurrency;
            document.getElementById('pricePerKmDisplay').textContent = pricePerKm.toFixed(2);
            document.getElementById('pricePerKmUnit').textContent = currentCurrency + '/km';
            if (totalPrice > 0) document.getElementById('calcBreakdown').innerHTML = `<span class="text-emerald-400">${pricePerKm.toFixed(2)}</span> ${currentCurrency}/km`;
            else document.getElementById('calcBreakdown').textContent = 'Podaj cenƒô';
            updateCustomTime();
            updateExpectedPrice();
            updatePriceComparison();
            updateWithoutStartCalculation();
            document.getElementById('resultsContainer').classList.remove('hidden');
        }
        
        function updateWithoutStartCalculation() {
            const totalPrice = parseFloat(document.getElementById('totalPrice').value) || 0;
            const rateWithoutStart = currentKmWithoutStart > 0 ? (totalPrice / currentKmWithoutStart) : 0;
            const expectedRate = parseFloat(document.getElementById('expectedRate').value) || 0;
            
            document.getElementById('kmWithoutStartDisplay').textContent = currentKmWithoutStart.toFixed(2);
            document.getElementById('priceWithoutStartDisplay').textContent = totalPrice.toFixed(0);
            document.getElementById('priceWithoutStartCurrency').textContent = currentCurrency;
            document.getElementById('rateWithoutStartDisplay').textContent = rateWithoutStart.toFixed(2);
            document.getElementById('rateWithoutStartUnit').textContent = `${currentCurrency}/km`;
            
            // Update results box
            document.getElementById('rateWithoutStartResult').textContent = rateWithoutStart.toFixed(2) + ' ' + currentCurrency + '/km';
            
            // Color comparison with expected rate
            const rateBox = document.getElementById('rateWithoutStartBox');
            const rateDisplay = document.getElementById('rateWithoutStartDisplay');
            
            if (expectedRate > 0 && rateWithoutStart > 0) {
                if (rateWithoutStart < expectedRate) {
                    // Below expected - RED
                    rateDisplay.classList.remove('text-cyan-300', 'text-green-400');
                    rateDisplay.classList.add('text-red-400');
                    rateBox.classList.remove('border-cyan-600/50', 'bg-cyan-900/50', 'border-green-500', 'bg-green-900/30');
                    rateBox.classList.add('border-red-500', 'bg-red-900/30');
                } else {
                    // Above or equal to expected - GREEN
                    rateDisplay.classList.remove('text-cyan-300', 'text-red-400');
                    rateDisplay.classList.add('text-green-400');
                    rateBox.classList.remove('border-cyan-600/50', 'bg-cyan-900/50', 'border-red-500', 'bg-red-900/30');
                    rateBox.classList.add('border-green-500', 'bg-green-900/30');
                }
            } else {
                // Reset to default
                rateDisplay.classList.remove('text-red-400', 'text-green-400');
                rateDisplay.classList.add('text-cyan-300');
                rateBox.classList.remove('border-red-500', 'bg-red-900/30', 'border-green-500', 'bg-green-900/30');
                rateBox.classList.add('border-cyan-600/50', 'bg-cyan-900/50');
            }
        }

        function formatDuration(seconds) {
            const h = Math.floor(seconds / 3600), m = Math.round((seconds % 3600) / 60);
            return h > 0 ? `${h}h ${m}m` : `${m} min`;
        }

        function updateCurrency() {
            currentCurrency = document.getElementById('currencySelector').value;
            document.getElementById('priceInputCurrency').textContent = currentCurrency;
            document.getElementById('pricePerKmUnit').textContent = `${currentCurrency}/km`;
            document.getElementById('expectedRateCurrency').textContent = `${currentCurrency}/km`;
            updatePricePerKmInput();
            updateExpectedPrice();
        }

        function updatePricePerKmInput() {
            const totalPrice = parseFloat(document.getElementById('totalPrice').value) || 0;
            const pricePerKm = currentTotalKm > 0 ? (totalPrice / currentTotalKm) : 0;
            document.getElementById('totalKmDisplay').textContent = currentTotalKm.toFixed(2);
            document.getElementById('pricePerKmDisplay').textContent = pricePerKm.toFixed(2);
            document.getElementById('pricePerKmUnit').textContent = `${currentCurrency}/km`;
            if (currentTotalKm > 0 && totalPrice > 0) document.getElementById('calcBreakdown').innerHTML = `<span class="text-emerald-400">${pricePerKm.toFixed(2)}</span> ${currentCurrency}/km`;
            else if (currentTotalKm > 0) document.getElementById('calcBreakdown').textContent = 'Podaj cenƒô';
            else document.getElementById('calcBreakdown').textContent = 'Oblicz trasƒô';
            if (currentTotalKm > 0) {
                document.getElementById('pricePerKm').textContent = pricePerKm.toFixed(2) + ' ' + currentCurrency;
                document.getElementById('displayTotalPrice').textContent = totalPrice.toFixed(0) + ' ' + currentCurrency;
            }
            updateExpectedPrice();
            updatePriceComparison();
            updateWithoutStartCalculation();
        }

        function updateCustomTime() {
            const speed = parseFloat(document.getElementById('customSpeed').value) || 80;
            if (currentTotalKm > 0 && speed > 0) {
                const timeHours = currentTotalKm / speed;
                const h = Math.floor(timeHours), m = Math.round((timeHours - h) * 60);
                document.getElementById('customTimeDisplay').textContent = `${h}h ${m}m`;
                document.getElementById('timeComparison').classList.remove('hidden');
                document.getElementById('osrmTimeCompare').textContent = formatDuration(currentOsrmTime);
                document.getElementById('customTimeCompare').textContent = `${h}h ${m}m`;
            } else {
                document.getElementById('customTimeDisplay').textContent = '0h 0m';
                document.getElementById('timeComparison').classList.add('hidden');
            }
        }

        function updateExpectedPrice() {
            const expectedRate = parseFloat(document.getElementById('expectedRate').value) || 0;
            const expectedTotal = expectedRate * currentTotalKm;
            document.getElementById('expectedTotalDisplay').innerHTML = `= ${expectedTotal.toFixed(0)} <span id="expectedTotalCurrency">${currentCurrency}</span>`;
            updatePriceComparison();
        }

        function updatePriceComparison() {
            const expectedRate = parseFloat(document.getElementById('expectedRate').value) || 0;
            const totalPrice = parseFloat(document.getElementById('totalPrice').value) || 0;
            const actualRate = currentTotalKm > 0 ? (totalPrice / currentTotalKm) : 0;
            
            const pricePerKmDisplay = document.getElementById('pricePerKmDisplay');
            const pricePerKmResult = document.getElementById('pricePerKm');
            const summaryBox = document.getElementById('pricePerKmSummaryBox');
            
            if (expectedRate > 0 && actualRate > 0) {
                if (actualRate < expectedRate) {
                    // Actual rate is lower than expected - BAD (red)
                    pricePerKmDisplay.classList.remove('text-emerald-400', 'text-green-400');
                    pricePerKmDisplay.classList.add('text-red-400');
                    pricePerKmResult.classList.remove('text-amber-400', 'text-green-400');
                    pricePerKmResult.classList.add('text-red-400');
                    if (summaryBox) {
                        summaryBox.classList.remove('border-emerald-600/50', 'bg-emerald-900/50', 'border-green-500');
                        summaryBox.classList.add('border-red-500', 'bg-red-900/30');
                    }
                } else {
                    // Actual rate is higher or equal to expected - GOOD (green)
                    pricePerKmDisplay.classList.remove('text-emerald-400', 'text-red-400');
                    pricePerKmDisplay.classList.add('text-green-400');
                    pricePerKmResult.classList.remove('text-amber-400', 'text-red-400');
                    pricePerKmResult.classList.add('text-green-400');
                    if (summaryBox) {
                        summaryBox.classList.remove('border-emerald-600/50', 'bg-emerald-900/50', 'border-red-500', 'bg-red-900/30');
                        summaryBox.classList.add('border-green-500', 'bg-green-900/30');
                    }
                }
            } else {
                // Reset to default colors
                pricePerKmDisplay.classList.remove('text-red-400', 'text-green-400');
                pricePerKmDisplay.classList.add('text-emerald-400');
                pricePerKmResult.classList.remove('text-red-400', 'text-green-400');
                pricePerKmResult.classList.add('text-amber-400');
                if (summaryBox) {
                    summaryBox.classList.remove('border-red-500', 'bg-red-900/30', 'border-green-500', 'bg-green-900/30');
                    summaryBox.classList.add('border-emerald-600/50', 'bg-emerald-900/50');
                }
            }
        }

        async function importFromGoogleMaps() {
            const urlInput = document.getElementById('googleMapsImport');
            let url = urlInput.value.trim();
            
            if (!url) {
                alert('Wklej URL z Google Maps');
                return;
            }
            
            // Clean URL - remove apostrophes and other unwanted characters
            url = url.replace(/'/g, '').replace(/'/g, '').replace(/`/g, '').replace(/"/g, '').replace(/"/g, '').replace(/"/g, '');
            
            try {
                let coordinates = [];
                
                // Parse different Google Maps URL formats
                
                // Format 1: /dir/lat,lng/lat,lng/lat,lng
                const dirMatch = url.match(/\/dir\/([^?]+)/);
                if (dirMatch) {
                    const parts = dirMatch[1].split('/').filter(p => p.trim());
                    for (const part of parts) {
                        // Clean the part from any remaining special characters
                        const cleanPart = part.replace(/'/g, '').replace(/'/g, '').replace(/`/g, '').trim();
                        
                        // Check if it's coordinates (lat,lng)
                        const coordMatch = cleanPart.match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                        if (coordMatch) {
                            coordinates.push({
                                lat: parseFloat(coordMatch[1]),
                                lng: parseFloat(coordMatch[2])
                            });
                        } else if (cleanPart && !cleanPart.startsWith('@') && !cleanPart.startsWith('data=')) {
                            // It's a place name, we'll geocode it later
                            coordinates.push({ address: decodeURIComponent(cleanPart.replace(/\+/g, ' ')) });
                        }
                    }
                }
                
                // Format 2: ?api=1&origin=...&destination=...&waypoints=...
                const apiMatch = url.match(/[?&]origin=([^&]+)/);
                const destMatch = url.match(/[?&]destination=([^&]+)/);
                const waypointsMatch = url.match(/[?&]waypoints=([^&]+)/);
                
                // Helper function to clean coordinates/addresses from special characters
                const cleanCoord = (str) => str.replace(/'/g, '').replace(/'/g, '').replace(/`/g, '').replace(/"/g, '').replace(/"/g, '').replace(/"/g, '').trim();
                
                if (apiMatch || destMatch) {
                    coordinates = []; // Reset if API format
                    
                    if (apiMatch) {
                        const origin = cleanCoord(decodeURIComponent(apiMatch[1]));
                        const coordMatch = origin.match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                        if (coordMatch) {
                            coordinates.push({ lat: parseFloat(coordMatch[1]), lng: parseFloat(coordMatch[2]) });
                        } else {
                            coordinates.push({ address: origin });
                        }
                    }
                    
                    if (waypointsMatch) {
                        const waypoints = cleanCoord(decodeURIComponent(waypointsMatch[1])).split('|');
                        for (const wp of waypoints) {
                            const cleanWp = cleanCoord(wp);
                            const coordMatch = cleanWp.match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                            if (coordMatch) {
                                coordinates.push({ lat: parseFloat(coordMatch[1]), lng: parseFloat(coordMatch[2]) });
                            } else {
                                coordinates.push({ address: cleanWp });
                            }
                        }
                    }
                    
                    if (destMatch) {
                        const dest = cleanCoord(decodeURIComponent(destMatch[1]));
                        const coordMatch = dest.match(/^(-?\d+\.?\d*),(-?\d+\.?\d*)$/);
                        if (coordMatch) {
                            coordinates.push({ lat: parseFloat(coordMatch[1]), lng: parseFloat(coordMatch[2]) });
                        } else {
                            coordinates.push({ address: dest });
                        }
                    }
                }
                
                // Format 3: /@lat,lng,zoom or /place/.../@lat,lng
                if (coordinates.length === 0) {
                    // Clean any apostrophes from the URL before matching
                    const cleanUrl = url.replace(/'/g, '').replace(/'/g, '').replace(/`/g, '');
                    const placeMatch = cleanUrl.match(/@(-?\d+\.?\d*),(-?\d+\.?\d*)/);
                    if (placeMatch) {
                        coordinates.push({
                            lat: parseFloat(placeMatch[1]),
                            lng: parseFloat(placeMatch[2])
                        });
                    }
                }
                
                if (coordinates.length === 0) {
                    alert('Nie znaleziono wsp√≥≈Çrzƒôdnych w URL. Upewnij siƒô, ≈ºe URL zawiera trasƒô (np. google.com/maps/dir/...)');
                    return;
                }
                
                // Clear existing waypoints and create new ones
                const container = document.getElementById('waypointsContainer');
                geocodedLocations = {};
                waypointEnabled = { start: true, end: true };
                
                // Reset container to base state
                container.innerHTML = `
                    <div class="waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600" data-waypoint="start" draggable="true" ondragstart="handleDragStart(event)" ondragend="handleDragEnd(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                        <div class="flex items-center gap-2">
                            <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                            </div>
                            <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, 'start')"></div>
                            <span class="waypoint-label w-6 h-6 bg-green-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">S</span>
                            <div class="input-wrapper">
                                <input type="text" id="waypoint-start" placeholder="Lokalizacja startowa" oninput="handleAutocomplete(this, 'start')" onfocus="handleAutocomplete(this, 'start')" class="w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-green-500">
                                <div id="dropdown-start" class="autocomplete-dropdown start-dropdown hidden"></div>
                            </div>
                        </div>
                    </div>`;
                
                // Process coordinates - first one is start, last one is end, middle ones are waypoints
                for (let i = 0; i < coordinates.length; i++) {
                    const coord = coordinates[i];
                    let displayName = '';
                    let geoData = null;
                    
                    // Reverse geocode if we have coordinates
                    if (coord.lat && coord.lng) {
                        try {
                            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${coord.lat}&lon=${coord.lng}&addressdetails=1`, { headers: { 'Accept-Language': 'pl' } });
                            const data = await response.json();
                            if (data && !data.error) {
                                const addr = data.address || {};
                                const postcode = addr.postcode || '';
                                const city = addr.city || addr.town || addr.village || addr.municipality || '';
                                displayName = postcode && city ? `${postcode} ${city}` : data.display_name.split(',')[0];
                                geoData = { lat: coord.lat, lng: coord.lng, display_name: data.display_name, postcode, city };
                            } else {
                                displayName = `${coord.lat.toFixed(5)}, ${coord.lng.toFixed(5)}`;
                                geoData = { lat: coord.lat, lng: coord.lng, display_name: displayName };
                            }
                        } catch (e) {
                            displayName = `${coord.lat.toFixed(5)}, ${coord.lng.toFixed(5)}`;
                            geoData = { lat: coord.lat, lng: coord.lng, display_name: displayName };
                        }
                    } else if (coord.address) {
                        displayName = coord.address;
                        // Try to geocode the address
                        try {
                            const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(coord.address)}&limit=1&addressdetails=1`, { headers: { 'Accept-Language': 'pl' } });
                            const data = await response.json();
                            if (data && data.length > 0) {
                                const place = data[0];
                                const addr = place.address || {};
                                const postcode = addr.postcode || '';
                                const city = addr.city || addr.town || addr.village || '';
                                displayName = postcode && city ? `${postcode} ${city}` : coord.address;
                                geoData = { lat: parseFloat(place.lat), lng: parseFloat(place.lon), display_name: place.display_name, postcode, city };
                            }
                        } catch (e) {}
                    }
                    
                    if (i === 0) {
                        // First point - Start
                        document.getElementById('waypoint-start').value = displayName;
                        if (geoData) geocodedLocations['start'] = geoData;
                    } else if (i === coordinates.length - 1) {
                        // Last point - End
                        document.getElementById('waypoint-end').value = displayName;
                        if (geoData) geocodedLocations['end'] = geoData;
                    } else {
                        // Middle points - Waypoints A, B, C, etc.
                        const label = waypointLabels[i - 1] || (i);
                        waypointEnabled[label] = true;
                        
                        const div = document.createElement('div');
                        div.className = 'waypoint-card bg-slate-700/50 rounded p-2 border border-slate-600';
                        div.setAttribute('data-waypoint', label);
                        div.setAttribute('draggable', 'true');
                        div.ondragstart = handleDragStart;
                        div.ondragend = handleDragEnd;
                        div.ondragover = handleDragOver;
                        div.ondragleave = handleDragLeave;
                        div.ondrop = handleDrop;
                        div.innerHTML = `
                            <div class="flex items-center gap-2">
                                <div class="drag-handle shrink-0 text-slate-400" title="PrzeciƒÖgnij aby zmieniƒá kolejno≈õƒá">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8h16M4 16h16"></path></svg>
                                </div>
                                <div class="toggle-switch active shrink-0" onclick="toggleWaypoint(this, '${label}')"></div>
                                <span class="waypoint-label w-6 h-6 bg-blue-600 rounded-full flex items-center justify-center text-xs font-bold shrink-0">${label}</span>
                                <div class="input-wrapper">
                                    <input type="text" class="waypoint-input w-full bg-slate-600 border border-slate-500 rounded px-2 py-1.5 text-xs text-white placeholder-slate-400 focus:outline-none focus:ring-1 focus:ring-blue-500" placeholder="Punkt ${label}" value="${displayName}" oninput="handleAutocomplete(this, '${label}')" onfocus="handleAutocomplete(this, '${label}')">
                                    <div id="dropdown-${label}" class="autocomplete-dropdown hidden"></div>
                                </div>
                                <button onclick="removeWaypoint(this)" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition shrink-0"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                            </div>`;
                        container.appendChild(div);
                        
                        if (geoData) geocodedLocations[label] = geoData;
                    }
                }
                
                waypointCount = Math.max(coordinates.length - 2, 0);
                urlInput.value = '';
                
                alert(`‚úÖ Zaimportowano ${coordinates.length} punkt√≥w trasy z Google Maps!`);
                
                // Auto-calculate route
                calculateRoute();
                
            } catch (e) {
                console.error('Import error:', e);
                alert('B≈ÇƒÖd podczas importowania URL. Sprawd≈∫ czy URL jest poprawny.');
            }
        }

        function exportToGoogleMaps() {
            const allPoints = [];
            
            // Collect start point
            const startInput = document.getElementById('waypoint-start').value.trim();
            if (startInput && waypointEnabled['start']) {
                if (geocodedLocations['start']) {
                    allPoints.push(geocodedLocations['start']);
                } else {
                    allPoints.push({ address: startInput });
                }
            }
            
            // Collect waypoints A, B, C, etc.
            const waypointCards = document.querySelectorAll('.waypoint-card[data-waypoint]:not([data-waypoint="start"]):not([data-waypoint="end"])');
            waypointCards.forEach(card => {
                const label = card.getAttribute('data-waypoint');
                const input = card.querySelector('.waypoint-input');
                const value = input?.value.trim();
                if (value && waypointEnabled[label]) {
                    if (geocodedLocations[label]) {
                        allPoints.push(geocodedLocations[label]);
                    } else {
                        allPoints.push({ address: value });
                    }
                }
            });
            
            // Collect end point
            const endInput = document.getElementById('waypoint-end').value.trim();
            if (endInput && waypointEnabled['end']) {
                if (geocodedLocations['end']) {
                    allPoints.push(geocodedLocations['end']);
                } else {
                    allPoints.push({ address: endInput });
                }
            }
            
            if (allPoints.length < 2) {
                alert('Dodaj co najmniej dwa punkty trasy aby eksportowaƒá do Google Maps');
                return;
            }
            
            // Build Google Maps URL using simple dir format
            // Format: https://www.google.com/maps/dir/location1/location2/location3
            const formatLocation = (point) => {
                if (point.lat && point.lng) {
                    return `${point.lat},${point.lng}`;
                } else if (point.address) {
                    return encodeURIComponent(point.address);
                }
                return '';
            };
            
            const locations = allPoints.map(formatLocation).join('/');
            const googleMapsUrl = `https://www.google.com/maps/dir/${locations}`;
            
            // Create a temporary link element and click it
            const link = document.createElement('a');
            link.href = googleMapsUrl;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Notes Functions
        let notesContent = '';

        function toggleNotes() {
            const panel = document.getElementById('notesPanel');
            const btn = document.getElementById('notesBtn');
            const isHidden = panel.classList.contains('hidden');
            
            panel.classList.toggle('hidden');
            btn.classList.toggle('active', isHidden);
            
            if (isHidden) {
                // Load saved notes from localStorage
                const savedNotes = localStorage.getItem('calculatorNotes') || '';
                document.getElementById('notesTextarea').value = savedNotes;
                updateCharCount();
            }
        }

        function saveNotes() {
            const textarea = document.getElementById('notesTextarea');
            notesContent = textarea.value;
            localStorage.setItem('calculatorNotes', notesContent);
            updateCharCount();
        }

        function clearNotes() {
            if (document.getElementById('notesTextarea').value === '') return;
            if (confirm('Czy na pewno chcesz wyczy≈õciƒá notatki?')) {
                document.getElementById('notesTextarea').value = '';
                notesContent = '';
                localStorage.removeItem('calculatorNotes');
                updateCharCount();
            }
        }

        function updateCharCount() {
            const count = document.getElementById('notesTextarea').value.length;
            document.getElementById('notesCharCount').textContent = count;
        }

        // Drivers List Functions
        let driversData = [];
        let driverIdCounter = 0;

        function toggleDriversList() {
            const panel = document.getElementById('driversListPanel');
            const btn = document.getElementById('driversListBtn');
            const isHidden = panel.classList.contains('hidden');
            
            panel.classList.toggle('hidden');
            btn.classList.toggle('active', isHidden);
            
            if (isHidden && driversData.length === 0) {
                // Add one empty row on first open
                addDriverRow();
            }
        }

        function addDriverRow() {
            const id = ++driverIdCounter;
            driversData.push({
                id,
                kierowca: '',
                ciagnik: '',
                nadwozie: '',
                naczepa: '',
                start: '',
                destynacja: '',
                status: 'wolny'
            });
            renderDriversTable();
        }

        function removeDriverRow(id) {
            driversData = driversData.filter(d => d.id !== id);
            renderDriversTable();
        }

        function updateDriverField(id, field, value) {
            const driver = driversData.find(d => d.id === id);
            if (driver) {
                driver[field] = value;
            }
        }

        function renderDriversTable() {
            const tbody = document.getElementById('driversTableBody');
            tbody.innerHTML = '';
            
            driversData.forEach(driver => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><input type="text" value="${driver.kierowca}" onchange="updateDriverField(${driver.id}, 'kierowca', this.value)" placeholder="Imiƒô i nazwisko"></td>
                    <td><input type="text" value="${driver.ciagnik}" onchange="updateDriverField(${driver.id}, 'ciagnik', this.value)" placeholder="Nr rejestracyjny"></td>
                    <td><input type="text" value="${driver.naczepa}" onchange="updateDriverField(${driver.id}, 'naczepa', this.value)" placeholder="Nr naczepy"></td>
                    <td><input type="text" value="${driver.start}" onchange="updateDriverField(${driver.id}, 'start', this.value)" placeholder="Miasto/Kraj"></td>
                    <td><input type="text" value="${driver.destynacja}" onchange="updateDriverField(${driver.id}, 'destynacja', this.value)" placeholder="Miasto/Kraj"></td>
                    <td>
                        <select onchange="updateDriverField(${driver.id}, 'nadwozie', this.value)">
                            <option value="" ${!driver.nadwozie ? 'selected' : ''}>Wybierz...</option>
                            <option value="standard" ${driver.nadwozie === 'standard' ? 'selected' : ''}>Standard</option>
                            <option value="ch≈Çodnia" ${driver.nadwozie === 'ch≈Çodnia' ? 'selected' : ''}>Ch≈Çodnia</option>
                            <option value="izoterma" ${driver.nadwozie === 'izoterma' ? 'selected' : ''}>Izoterma</option>
                        </select>
                    </td>
                    <td>
                        <select onchange="updateDriverField(${driver.id}, 'status', this.value)">
                            <option value="wolny" ${driver.status === 'wolny' ? 'selected' : ''}>üü¢ Wolny</option>
                            <option value="w-trasie" ${driver.status === 'w-trasie' ? 'selected' : ''}>üîµ W trasie</option>
                            <option value="zaladowany" ${driver.status === 'zaladowany' ? 'selected' : ''}>üü† Za≈Çadowany</option>
                            <option value="rozladowany" ${driver.status === 'rozladowany' ? 'selected' : ''}>üü£ Roz≈Çadowany</option>
                            <option value="awaria" ${driver.status === 'awaria' ? 'selected' : ''}>üî¥ Awaria</option>
                            <option value="urlop" ${driver.status === 'urlop' ? 'selected' : ''}>‚ö´ Rezerwacja</option>
                        </select>
                    </td>
                    <td class="text-center">
                        <button onclick="removeDriverRow(${driver.id})" class="text-red-400 hover:text-red-300 p-1 hover:bg-red-900/30 rounded transition">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
            
            updateDriversCount();
        }

        function updateDriversCount() {
            const count = driversData.length;
            document.getElementById('driversCount').textContent = `${count} kierowc${count === 1 ? 'a' : count < 5 ? '√≥w' : '√≥w'}`;
        }

        function clearAllDrivers() {
            if (driversData.length === 0) return;
            if (confirm('Czy na pewno chcesz usunƒÖƒá wszystkich kierowc√≥w z listy?')) {
                driversData = [];
                renderDriversTable();
            }
        }

        function exportDriversToCSV() {
            if (driversData.length === 0) {
                alert('Brak danych do eksportu');
                return;
            }
            
            const headers = ['Kierowca', 'CiƒÖgnik', 'Naczepa', 'Start', 'Destynacja', 'Nadwozie', 'Status'];
            const rows = driversData.map(d => [
                d.kierowca, d.ciagnik, d.naczepa, d.start, d.destynacja, d.nadwozie, d.status
            ].map(val => `"${(val || '').replace(/"/g, '""')}"`).join(','));
            
            const csv = [headers.join(','), ...rows].join('\n');
            const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `lista_kierowcow_${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function importDriversFromCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    const lines = text.split('\n').filter(line => line.trim());
                    
                    if (lines.length < 2) {
                        alert('Plik CSV jest pusty lub zawiera tylko nag≈Ç√≥wki');
                        return;
                    }
                    
                    // Skip header row and parse data
                    const importedDrivers = [];
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        // Parse CSV line (handle quoted values)
                        const values = [];
                        let current = '';
                        let inQuotes = false;
                        
                        for (let j = 0; j < line.length; j++) {
                            const char = line[j];
                            if (char === '"') {
                                if (inQuotes && line[j + 1] === '"') {
                                    current += '"';
                                    j++;
                                } else {
                                    inQuotes = !inQuotes;
                                }
                            } else if (char === ',' && !inQuotes) {
                                values.push(current.trim());
                                current = '';
                            } else {
                                current += char;
                            }
                        }
                        values.push(current.trim());
                        
                        // Map values to driver object
                        const statusMap = {
                            'wolny': 'wolny',
                            'w trasie': 'w-trasie',
                            'w-trasie': 'w-trasie',
                            'za≈Çadowany': 'zaladowany',
                            'zaladowany': 'zaladowany',
                            'roz≈Çadowany': 'rozladowany',
                            'rozladowany': 'rozladowany',
                            'awaria': 'awaria',
                            'rezerwacja': 'urlop',
                            'urlop': 'urlop'
                        };
                        
                        const rawStatus = (values[6] || 'wolny').toLowerCase().trim();
                        const status = statusMap[rawStatus] || 'wolny';
                        
                        // Map nadwozie values
                        const nadwozieMap = {
                            'standard': 'standard',
                            'ch≈Çodnia': 'ch≈Çodnia',
                            'chlodnia': 'ch≈Çodnia',
                            'izoterma': 'izoterma'
                        };
                        const rawNadwozie = (values[5] || '').toLowerCase().trim();
                        const nadwozie = nadwozieMap[rawNadwozie] || values[5] || '';
                        
                        importedDrivers.push({
                            id: ++driverIdCounter,
                            kierowca: values[0] || '',
                            ciagnik: values[1] || '',
                            naczepa: values[2] || '',
                            start: values[3] || '',
                            destynacja: values[4] || '',
                            nadwozie: nadwozie,
                            status: status
                        });
                    }
                    
                    if (importedDrivers.length === 0) {
                        alert('Nie znaleziono danych do importu');
                        return;
                    }
                    
                    // Ask user if they want to replace or append
                    const action = driversData.length > 0 
                        ? confirm('Czy chcesz zastƒÖpiƒá istniejƒÖce dane? (OK = ZastƒÖp, Anuluj = Dodaj do istniejƒÖcych)')
                        : true;
                    
                    if (action || driversData.length === 0) {
                        driversData = importedDrivers;
                    } else {
                        driversData = [...driversData, ...importedDrivers];
                    }
                    
                    renderDriversTable();
                    alert(`Zaimportowano ${importedDrivers.length} kierowc√≥w`);
                    
                } catch (err) {
                    console.error('Import error:', err);
                    alert('B≈ÇƒÖd podczas importu pliku CSV');
                }
                
                // Reset file input
                event.target.value = '';
            };
            
            reader.readAsText(file, 'UTF-8');
        }
    </script>
</body>
</html>
